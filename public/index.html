<!DOCTYPE html>
<html>
<head>
    <title>Diep.io RPG Single Player</title>
    <style>
        body { margin: 0; background: #1a1a1a; }
        canvas { display: block; background: #222; margin: auto; }
        #hud, #skills {
            position: absolute;
            left: 20px;
            font-family: Arial, sans-serif;
            user-select: none;
            color: #fff;
        }
        #hud { top: 16px; font-size: 22px; z-index: 10; }
        #skills {
            top: 80px;
            background: rgba(30,30,40,0.97);
            padding: 18px 26px 18px 26px;
            border-radius: 16px;
            border: 2px solid #345;
            display: none;
            z-index: 12;
        }
        #eventMsg {
            position: absolute;
            top: 28%;
            left: 0;
            right: 0;
            text-align: center;
            color: #fff;
            font-size: 38px;
            font-family: Arial, sans-serif;
            font-weight: bold;
            z-index: 30;
            text-shadow: 2px 2px 16px #000, 0 0 12px #fff;
            display: none;
            pointer-events: none;
        }
        #dmgReduceIcon {
            position: absolute;
            top: 14px;
            right: 32px;
            background: #1a2945cc;
            border-radius: 50%;
            border: 3px solid #58ffb7;
            width: 58px; height: 58px;
            box-shadow: 0 0 16px #14f9;
            z-index: 19;
            display: none;
            align-items: center;
            justify-content: center;
        }
        #dmgReduceIcon span {
            font-size: 31px;
            color: #58ffb7;
            display: block;
            font-weight: bold;
            text-shadow: 1px 1px 5px #0f4, 0 0 10px #000;
        }
        #xpbar-ct {
            margin-top: 7px;
            width: 320px;
            height: 26px;
            background: #444;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #67d2ff;
        }
        #xpbar {
            height: 100%;
            background: linear-gradient(90deg,#1fd1f9,#88e8a0);
            width: 0%;
            border-radius: 10px;
            transition: width 0.22s cubic-bezier(.4,2.3,.2,1);
        }
        #deathMsg {
            position: absolute;
            top: 40%;
            left: 0;
            right: 0;
            color: #fff;
            font-size: 48px;
            font-family: Arial, sans-serif;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 16px #000, 0 0 12px #46f9;
            z-index: 20;
            display: none;
        }
    </style>
</head>
<body>
    <div id="hud">
        <span id="score"></span>
        <button id="openSkills">Habilidades (<span id="points">0</span> pts)</button>
        <div id="xpbar-ct">
            <div id="xpbar"></div>
        </div>
    </div>
    <div id="skills"></div>
    <div id="eventMsg"></div>
    <div id="dmgReduceIcon"><span title="Redu√ß√£o permanente de dano">üõ°Ô∏è<br><span style="font-size:17px;">-20%</span></span></div>
    <div id="deathMsg"></div>
    <canvas id="game"></canvas>
    <script>
    // ========= Refer√™ncias ===========
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreDiv = document.getElementById('score');
    const pointsSpan = document.getElementById('points');
    const xpbar = document.getElementById('xpbar');
    const skillsDiv = document.getElementById('skills');
    const openSkills = document.getElementById('openSkills');
    const deathMsg = document.getElementById('deathMsg');
    const eventMsg = document.getElementById('eventMsg');
    const dmgReduceIcon = document.getElementById('dmgReduceIcon');

    // ============ CONFIGS ============
    const BASE_HP = 100;
    const BASE_DMG = 25;
    const BASE_SPEED = 3.2;
    const BASE_DEF = 0;
    const BASE_MOB = 1.0;

    // ============ MAPA ===============
    let viewW = window.innerWidth, viewH = window.innerHeight;
    const MAP_W = viewW * 3, MAP_H = viewH * 3;

    // Zonas seguras (esquerda, centro, direita)
    const SAFE_ZONES = [
        { x: MAP_W / 6, y: MAP_H / 2, r: 160 },
        { x: MAP_W / 2, y: MAP_H / 2, r: 160 },
        { x: MAP_W * 5 / 6, y: MAP_H / 2, r: 160 }
    ];

    // ============ PLAYER ============
    const player = {
        x: SAFE_ZONES[1].x, y: SAFE_ZONES[1].y,
        angle: 0,
        radius: 28,
        color: "#4ccfff",
        hp: BASE_HP,
        maxHp: BASE_HP,
        dmg: BASE_DMG,
        speed: BASE_SPEED,
        def: BASE_DEF,
        mob: BASE_MOB,
        xp: 0,
        level: 1,
        xpToNext: 60,
        points: 0,
        skill: { dmg: 0, def: 0, hp: 0, regen: 0, speed: 0, mob: 0 },
        alive: true,
        respawnTimer: 0,
        contactBlocks: {},
        hasDmgReduction: false // 20% buff p√≥s-boss
    };

    function getPlayerRegen() {
        const pts = player.skill.regen;
        if (pts < 1) return 0;
        let total = 0;
        for (let i = 1; i <= pts; i++) {
            if (i <= 3) total += 0.01;
            else if (i <= 6) total += 0.02;
            else total += 0.03;
        }
        return total;
    }
    function getPlayerDefPercent() {
        let percent = Math.min(0.8, (Math.floor(player.skill.def/3) * 0.005));
        if (player.hasDmgReduction) percent += 0.20;
        return Math.min(percent, 0.95); // 95% m√°x s√≥ por seguran√ßa
    }
    function getPlayerDmgMultiplier() {
        return 1 + (player.skill.dmg * 0.001);
    }
    function playerBaseStats() {
        let buffHp = 1 + (Math.floor(player.level/10) * 0.015);
        let buffDmg = 1 + (Math.floor(player.level/10) * 0.01);
        player.maxHp = Math.floor(BASE_HP * buffHp + player.skill.hp * 25);
        player.dmg = Math.floor(BASE_DMG * buffDmg * getPlayerDmgMultiplier());
        player.def = BASE_DEF + Math.floor(player.skill.def/3);
        player.speed = BASE_SPEED + player.skill.speed * 0.14;
        player.mob = BASE_MOB + Math.min(0.5, player.skill.mob * 0.02);
        if (player.hp > player.maxHp) player.hp = player.maxHp;
    }
    function xpToNext(level) {
        return Math.floor(60 + 12*Math.pow(level, 1.22));
    }

    // ============ BLOCO ============

    const BLOCK_TYPES = {
        yellow: { color: "#f0e130", hp: 24, xp: 12, dmg: 0.1, size: 32, slow: 0.8 },
        blue:   { color: "#3cf", hp: 48, xp: 24, dmg: 0.2, size: 32, slow: 0.6 },
        purple: { color: "#b36ef8", hp: 180, xp: 120, dmg: 1.8, size: 64, slow: 0.2 }
    };
    const blocks = [];
    const NUM_BLOCKS = 14, NUM_BLUE = 4, NUM_PURPLE = 2;
    function spawnBlock(type = "yellow") {
        let bx, by, safe;
        do {
            bx = Math.random() * (MAP_W-120) + 60;
            by = Math.random() * (MAP_H-120) + 60;
            safe = SAFE_ZONES.some(z => Math.hypot(bx-z.x,by-z.y) < z.r+50);
        } while (safe);
        let t = BLOCK_TYPES[type];
        blocks.push({
            x: bx, y: by, alive: true, type: type, hp: t.hp, id: Math.random().toString(36).slice(2)
        });
    }
    for (let i = 0; i < NUM_BLOCKS; i++) spawnBlock("yellow");
    for (let i = 0; i < NUM_BLUE; i++) spawnBlock("blue");
    for (let i = 0; i < NUM_PURPLE; i++) spawnBlock("purple");

    // ========== INIMIGOS ===========
    // Normais
    const enemies = [];
    const ENEMY_SIZE = 38, MAX_ENEMIES = 15;
    const ENEMY_RESPAWN_MS = 120_000;

    function spawnEnemy() {
        let ex, ey, safe;
        do {
            ex = Math.random() * (MAP_W-160) + 80;
            ey = Math.random() * (MAP_H-160) + 80;
            safe = SAFE_ZONES.some(z => Math.hypot(ex-z.x,ey-z.y) < z.r+ENEMY_SIZE/2+8);
        } while (safe);
        enemies.push({x: ex, y: ey, hp: 42+Math.random()*60, alive: true, respawnTime: null, type: "normal"});
    }
    for (let i = 0; i < MAX_ENEMIES; i++) spawnEnemy();

    // ========== ATIRADOR ===========
    const shooterEnemies = [];
    const SHOOTER_SIZE = 38, MAX_SHOOTERS = 4, SHOOTER_RESPAWN_MS = 100_000;
    const SHOOTER_FIRE_RATE = 3.0, SHOOTER_DMG = 25, SHOOTER_BULLET_SPEED = 9;

    function spawnShooter() {
        let ex, ey, safe;
        do {
            ex = Math.random() * (MAP_W-180) + 90;
            ey = Math.random() * (MAP_H-180) + 90;
            safe = SAFE_ZONES.some(z => Math.hypot(ex-z.x,ey-z.y) < z.r+SHOOTER_SIZE/2+18);
        } while (safe);
        shooterEnemies.push({
            x: ex, y: ey, hp: 70+Math.random()*45, alive: true, fireTimer: Math.random()*3, type: "shooter"
        });
    }

    // Tiros disparados pelos atiradores
    const shooterBullets = [];

    // ========== BOSS ===========
    let boss = null;
    const BOSS_SIZE = 78;
    const BOSS_SPAWNED = { spawned: false, killed: false };
    const BOSS_SPAWN_HP = 6000;
    const BOSS_DMG = 120;
    const BOSS_HIT_RATE = 4.0;
    let bossHitTimer = 0;

    function spawnBoss() {
        let ex, ey, safe;
        do {
            ex = Math.random() * (MAP_W-250) + 125;
            ey = Math.random() * (MAP_H-250) + 125;
            safe = SAFE_ZONES.some(z => Math.hypot(ex-z.x,ey-z.y) < z.r+BOSS_SIZE/2+28);
        } while (safe);
        boss = {
            x: ex, y: ey, hp: BOSS_SPAWN_HP, alive: true, type: "boss",
            dmgReduce: 0.20 // 20% de redu√ß√£o de dano tomado
        };
        bossHitTimer = 0;
    }

    // TIROS do player
    const bullets = [];
    const BULLET_SPEED = 10, BULLET_LIFE = 38;

    // CONTROLES
    const keys = {};
    document.addEventListener('keydown', e => {
        if (e.key === "Escape") skillsDiv.style.display = "none";
        keys[e.key.toLowerCase()] = true;
    });
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // Mira
    let mouseX = viewW/2, mouseY = viewH/2;
    canvas.addEventListener('mousemove', e => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    // Atirar
    document.addEventListener('mousedown', e => {
        if (!player.alive || e.button !== 0) return;
        let dx = mouseX - (player.x - cam.x), dy = mouseY - (player.y - cam.y);
        let angle = Math.atan2(dy, dx);
        bullets.push({
            x: player.x + Math.cos(angle) * (player.radius+15),
            y: player.y + Math.sin(angle) * (player.radius+15),
            dx: Math.cos(angle) * BULLET_SPEED * player.mob,
            dy: Math.sin(angle) * BULLET_SPEED * player.mob,
            life: BULLET_LIFE,
            dmg: player.dmg
        });
    });

    // GAME LOOP
    const cam = {x: 0, y: 0};
    let msgQueue = [], msgTime = 0;

    function showEventMsg(msg, duration=3) {
        msgQueue.push({msg: msg, t: duration});
    }

    // Eventos para spawn de inimigos especiais/mensagens
    let shooterUnlocked = false, bossUnlocked = false, bossMsg1 = false, bossMsg2 = false;

    function update() {
        // ===== Mensagens/eventos =====
        if (player.level >= 10 && !shooterUnlocked) {
            showEventMsg("posso sentir sua presen√ßa", 3.4);
            shooterUnlocked = true;
        }
        if (player.level >= 15 && shooterEnemies.length === 0) {
            showEventMsg("e Agora o campo de batalha se agita", 3.4);
            // Spawna atiradores!
            for (let i = 0; i < MAX_SHOOTERS; i++) spawnShooter();
        }
        if (player.level >= 30 && !bossMsg1) {
            showEventMsg("Um Novo Poder ???", 3.8);
            bossMsg1 = true;
        }
        if (player.level >= 40 && !bossMsg2) {
            showEventMsg("Yo Ishi Ten Kai!", 3.6);
            bossMsg2 = true;
        }
        if (player.level >= 40 && !BOSS_SPAWNED.spawned && !BOSS_SPAWNED.killed) {
            spawnBoss();
            BOSS_SPAWNED.spawned = true;
        }

        // ===== Player morte/respawn =====
        if (!player.alive) {
            player.respawnTimer -= 1/60;
            if (player.respawnTimer <= 0) respawnPlayer();
            return;
        }

        // ===== Movimento/slow por bloco =====
        let vx = 0, vy = 0, mob = player.mob, speed = player.speed;
        let inSafeZone = isInSafeZone(player.x, player.y);
        let blockSlowest = 1.0;

        // Blocos
        for (let block of blocks) {
            if (!block.alive) continue;
            let t = BLOCK_TYPES[block.type];
            // C√≠rculo x quadrado (player vs bloco)
            let closestX
